package csw.opcDemo.hcd2

import java.util.function.Consumer

import akka.actor._
import com.digitalpetri.opcua.stack.core.types.builtin.DataValue
import csw.opc.server.Hcd2Namespace
import csw.util.config.StateVariable.CurrentState
import csw.util.config.Configurations._
import scala.concurrent.duration._
import csw.util.config.ConfigDSL._

import scala.language.postfixOps

object Hcd2Worker {
  def props(prefix: String): Props = Props(classOf[Hcd2Worker], prefix)

  // Message used to try/retry to connect to the OPC server
  case object TryOpcConnection

  // Message requesting current state of HCD values
  case object RequestCurrentState
}

/**
 * An actor that does the work of matching a configuration
 */
class Hcd2Worker(prefix: String) extends Actor with ActorLogging {
  import context.dispatcher
  import Hcd2._
  import Hcd2Worker._

  log.info(s"Started worker for $prefix")

  val name = prefix.split('.').last
  val choices = if (name == "filter") Hcd2Namespace.FILTERS else Hcd2Namespace.DISPERSERS
  val key = if (prefix == filterPrefix) filterKey else disperserKey

  // We can't do anything until the OPC UA server is available
  context.become(waitingForOpcServer)
  tryOpcConnection()

  override def receive: Receive = Actor.emptyBehavior

  // State while waiting for a connection to the OPC UA server
  private def waitingForOpcServer: Receive = {
    case TryOpcConnection => tryOpcConnection()
    case s: SetupConfig   => log.error("Not connected to OPC server")
    case x                => log.error(s"Unexpected message $x")
  }

  // State while connected to the OPC server
  private def connected(opcClient: Hcd2OpcUaClient, currentPos: String): Receive = {
    case s: SetupConfig => submit(s, opcClient)

    // Send the parent the current state
    case RequestCurrentState =>
      context.parent ! cs(prefix, key -> currentPos)

    case x => log.error(s"Unexpected message $x")
  }

  private def tryOpcConnection(): Unit = {
    try {
      val opcClient = new Hcd2OpcUaClient()

      // Subscribe to changes in the filter or disperser opcua variable and then update the state variable
      opcClient.subscribe(name, new Consumer[DataValue] {
        override def accept(v: DataValue): Unit = {
          val s = v.getValue.getValue.toString
          log.info(s"HCD subscriber: value for $name received: $s")
        }
      })

      // Subscribe to changes in the opcua filterPos or disperserPos opcua variable and then set the telemetry value
      // (These values are generated by the HCD2 OPC UA server to simulate a wheel turning through different values)
      opcClient.subscribe(s"${name}Pos", new Consumer[DataValue] {
        override def accept(v: DataValue): Unit = {
          val pos = v.getValue.getValue.asInstanceOf[Int]
          val choice = choices(pos)
          context.become(connected(opcClient, choice))
          log.info(s"HCD subscriber: value for ${name}Pos received: $choice")
          context.parent ! cs(prefix, key -> choice)
        }
      })

      log.info(s"$name: Connected to OPC server")
      context.become(connected(opcClient, choices(0)))
    } catch {
      case ex: Exception =>
        // Retry the connection in a second
        log.warning(s"$name: Failed to connect to OPC server (${ex.getMessage}). Will retry in 1 sec.")
        context.system.scheduler.scheduleOnce(1.second, self, TryOpcConnection)
    }
  }

  /**
   * Called when a configuration is submitted
   */
  def submit(setupConfig: SetupConfig, opcClient: Hcd2OpcUaClient): Unit = {
    setupConfig.get(key).foreach { value =>
      opcClient.setValue(name, value.head)
    }
  }
}

